<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Gaussian.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">reciprocal</a> &gt; <a href="index.source.html" class="el_package">reciprocal.number.complex</a> &gt; <span class="el_source">Gaussian.java</span></div><h1>Gaussian.java</h1><pre class="source lang-java linenums">package reciprocal.number.complex;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.util.Objects.requireNonNull;

import com.google.common.math.LongMath;
import java.io.Serial;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Set;
import org.jetbrains.annotations.NotNull;

/**
 * Immutable implementation of a Gaussian integer that uses {@link Long} as
 * type for its real and imaginary part
 *
 * @since 0.0.1
 */
public final class Gaussian extends AbstractComplex&lt;@NotNull Long, @NotNull Gaussian, @NotNull Complex,
    @NotNull Double, @NotNull PolarForm&gt; {
    /**
     * 0
     *
     * @since 0.0.1
     */
<span class="fc" id="L27">    public static final @NotNull Gaussian ZERO = ofReal(0L);</span>

    /**
     * 1
     *
     * @since 0.0.1
     */
<span class="fc" id="L34">    public static final @NotNull Gaussian ONE = ofReal(1L);</span>

    /**
     * i
     *
     * @since 0.0.1
     */
<span class="fc" id="L41">    public static final @NotNull Gaussian I = ofImaginary(1L);</span>

    /**
     * -1
     *
     * @since 0.0.1
     */
<span class="fc" id="L48">    public static final @NotNull Gaussian MINUS_ONE = ONE.negate();</span>

    /**
     * -i
     *
     * @since 0.0.1
     */
<span class="fc" id="L55">    public static final @NotNull Gaussian MINUS_I = I.negate();</span>

    /**
     * Units
     *
     * @since 0.0.1
     */
<span class="fc" id="L62">    public static final @NotNull Set&lt;@NotNull Gaussian&gt; UNITS = Set.of(ONE, I, MINUS_ONE, MINUS_I);</span>

    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * Constructor
     *
     * @param real real part
     * @param imaginary imaginary part
     * @since 0.0.1
     */
    public Gaussian(final long real, final long imaginary) {
<span class="fc" id="L75">        super(real, imaginary);</span>
<span class="fc" id="L76">    }</span>

    /**
     * Static factory method
     *
     * @param real real part
     * @return real + 0 * i
     * @since 0.0.1
     */
    public static @NotNull Gaussian ofReal(final long real) {
<span class="fc" id="L86">        return new Gaussian(real, 0L);</span>
    }

    /**
     * Static factory method
     *
     * @param imaginary imaginary part
     * @return 0 + imaginary * i
     * @since 0.0.1
     */
    public static @NotNull Gaussian ofImaginary(final long imaginary) {
<span class="fc" id="L97">        return new Gaussian(0L, imaginary);</span>
    }

    @Override
    public boolean isInvertible() {
<span class="fc" id="L102">        return toComplex().isInvertible();</span>
    }

    @Override
    public @NotNull Gaussian add(final @NotNull Gaussian summand) {
<span class="fc" id="L107">        requireNonNull(summand, &quot;summand&quot;);</span>
<span class="fc" id="L108">        final var re = getReal() + summand.getReal();</span>
<span class="fc" id="L109">        final var im = getImaginary() + summand.getImaginary();</span>
<span class="fc" id="L110">        return new Gaussian(re, im);</span>
    }

    @Override
    public @NotNull Gaussian subtract(final @NotNull Gaussian subtrahend) {
<span class="fc" id="L115">        requireNonNull(subtrahend, &quot;subtrahend&quot;);</span>
<span class="fc" id="L116">        final var re = getReal() - subtrahend.getReal();</span>
<span class="fc" id="L117">        final var im = getImaginary() - subtrahend.getImaginary();</span>
<span class="fc" id="L118">        return new Gaussian(re, im);</span>
    }

    @Override
    public @NotNull Gaussian multiply(final @NotNull Gaussian factor) {
<span class="fc" id="L123">        requireNonNull(factor, &quot;factor&quot;);</span>
<span class="fc" id="L124">        final var re = getReal() * factor.getReal() - getImaginary() * factor.getImaginary();</span>
<span class="fc" id="L125">        final var im = getReal() * factor.getImaginary() + getImaginary() * factor.getReal();</span>
<span class="fc" id="L126">        return new Gaussian(re, im);</span>
    }

    @Override
    public @NotNull Complex divide(final @NotNull Gaussian divisor) {
<span class="fc" id="L131">        requireNonNull(divisor, &quot;divisor&quot;);</span>
<span class="fc" id="L132">        checkArgument(divisor.isInvertible(), &quot;divisor expected to be invertible but divisor = %s&quot;, divisor);</span>
<span class="fc" id="L133">        final var den = Math.pow(divisor.getReal(), 2.0D) + Math.pow(divisor.getImaginary(), 2.0D);</span>
<span class="fc" id="L134">        final var re = (getReal() * divisor.getReal() + getImaginary() * divisor.getImaginary()) / den;</span>
<span class="fc" id="L135">        final var im = (getImaginary() * divisor.getReal() - getReal() * divisor.getImaginary()) / den;</span>
<span class="fc" id="L136">        return new Complex(re, im);</span>
    }

    @Override
    public @NotNull Complex pow(final int exponent) {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (exponent &lt; 0) {</span>
<span class="fc" id="L142">            return toComplex().multiply(pow(-exponent - 1)).invert();</span>
        }
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (exponent &gt; 0) {</span>
<span class="fc" id="L145">            return toComplex().multiply(pow(exponent - 1));</span>
        }
<span class="fc" id="L147">        return Complex.ONE;</span>
    }

    @Override
    public @NotNull Gaussian negate() {
<span class="fc" id="L152">        return new Gaussian(-getReal(), -getImaginary());</span>
    }

    @Override
    public @NotNull Complex invert() {
<span class="fc" id="L157">        checkState(isInvertible(), &quot;this expected to be invertible but this = %s&quot;, this);</span>
<span class="fc" id="L158">        return ONE.divide(this);</span>
    }

    @Override
    public @NotNull Double abs() {
<span class="fc" id="L163">        return Math.sqrt(absPow2());</span>
    }

    @Override
    public @NotNull Gaussian conjugate() {
<span class="fc" id="L168">        return new Gaussian(getReal(), -getImaginary());</span>
    }

    @Override
    public @NotNull Double argument() {
<span class="fc" id="L173">        checkState(isInvertible(), &quot;this expected to be invertible but this = %s&quot;, this);</span>
<span class="fc" id="L174">        final var acos = Math.acos(getReal() / abs());</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">        return getImaginary() &lt; 0.0D ? -acos : acos;</span>
    }

    @Override
    public @NotNull BigInteger toBigInteger() {
<span class="fc" id="L180">        return BigInteger.valueOf(longValue());</span>
    }

    @Override
    public @NotNull BigDecimal toBigDecimal() {
<span class="fc" id="L185">        return BigDecimal.valueOf(doubleValue());</span>
    }

    /**
     * Returns this as {@link Complex}
     *
     * @return {@link Complex}
     * @since 0.0.1
     */
    public @NotNull Complex toComplex() {
<span class="fc" id="L195">        return new Complex(getReal(), getImaginary());</span>
    }

    /**
     * Returns this as {@link BigGaussian}
     *
     * @return {@link BigGaussian}
     * @since 0.0.1
     */
    public @NotNull BigGaussian toBigGaussian() {
<span class="nc" id="L205">        return new BigGaussian(BigInteger.valueOf(getReal()), BigInteger.valueOf(getImaginary()));</span>
    }

    /**
     * Returns this as {@link BigComplex}
     *
     * @return {@link BigComplex}
     * @since 0.0.1
     */
    public @NotNull BigComplex toBigComplex() {
<span class="nc" id="L215">        return new BigComplex(BigDecimal.valueOf(getReal()), BigDecimal.valueOf(getImaginary()));</span>
    }

    @Override
    public @NotNull PolarForm toPolarForm() {
<span class="fc" id="L220">        checkState(isInvertible(), &quot;this expected to be invertible but this = %s&quot;, this);</span>
<span class="fc" id="L221">        return new PolarForm(abs(), argument());</span>
    }

    @Override
    public boolean equalsByComparing(final @NotNull Gaussian other) {
<span class="fc" id="L226">        requireNonNull(other, &quot;other&quot;);</span>
<span class="fc bfc" id="L227" title="All 4 branches covered.">        return getReal().compareTo(other.getReal()) == 0 &amp;&amp; getImaginary().compareTo(other.getImaginary()) == 0;</span>
    }

    @Override
    protected @NotNull Long absPow2() {
<span class="fc" id="L232">        return LongMath.pow(getReal(), 2) + LongMath.pow(getImaginary(), 2);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>